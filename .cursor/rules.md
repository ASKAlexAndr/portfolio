# Правила для AI-агентов (Cursor / Copilot / и т.п.)
# Project AI Rules — Style & Conventions

## Tech stack
- Language: TypeScript (strict: true).
- Framework: Next.js 15 (App Router). React 19.
- Styling: Tailwind CSS + clsx + tailwind-merge.
- i18n: next-i18next + react-i18next.
- Animations: framer-motion.
- Icons: lucide-react (предпочтительно), react-icons — при необходимости.
- Package manager: yarn (обязательно). Команды: `yarn`, `yarn add`, `yarn remove`, `yarn upgrade`.
- Lint: eslint-config-next. Форматирование Prettier.

## General principles
- Пиши простой, предсказуемый, типобезопасный код. Предпочитай явные типы и узкие интерфейсы.
- Не используй чувствительные данные. Всегда подставляй плейсхолдеры: <API_KEY>, <ENDPOINT_URL>, <ORG_ID>.
- Следуй правилам ниже; при конфликте — придерживайся Next.js/React best practices и настроек ESLint проекта.

## Project structure & naming
- App Router: `app/` для маршрутов. Компоненты: `src/components/`, хелперы: `src/lib/`, хуки: `src/hooks/`, типы: `src/types/`, стили: `src/styles/`.
- Имена файлов:
  - Компоненты: PascalCase: `Button.tsx`, страницы в `app/` — по правилам Next.js.
  - Хуки: `useXxx.ts`.
  - Утилиты: `xxx.ts`.
- Экспорт по умолчанию избегать для переиспользуемых утилит/хуков. Предпочитать именованные экспорты.

## TypeScript
- Включать строгую типизацию пропсов и возвращаемых значений.
- Не использовать `any`. Если необходимо — `unknown` + узкая проверка.
- Типы для данных и API — в `src/types/`. Общие типы — с префиксом T: `type TUser = { ... }`.

## React/Next
- React 19: не импортируй React по умолчанию в компонентах (JSX runtime). Импортируй только именованные хуки/утилиты.
- Разделяй Server/Client компоненты. Клиентские помечай "use client" в начале файла.
- Server actions допускаются, учитывай кэширование Next (`revalidate`, `cache`).
- В компонентах: без побочных эффектов внутри рендера. Эффекты — в `useEffect`.
- Не использовать legacy API. Предпочитать новые хуки и паттерны.
- Пропсы: минимально необходимый контракт, избегай «мешков» с пропсами.

## CSS/Tailwind
- Для стилей использовать Tailwind. Не использовать inline-стили без необходимости.
- Классы объединять через `clsx` и нормализовать через `tailwind-merge` (обертка `cn`-утилита).
- Не плодить кастомные классы, если есть эквиваленты в Tailwind.
- Темизация/варианты — через условные классы, без сложных динамических вычислений в рендере.

## Accessibility
- Всегда указывать доступные названия элементов: aria-label/aria-labelledby.
- Кликабельные элементы — семантически корректные теги (button/a), фокусируемость и роли.
- Цветовой контраст — соответствует WCAG AA.

## i18n
- Строки UI — через i18n. Не хардкодить текст.
- Использовать неймспейсы: `common`, `auth`, `dashboard`, и т.п.
- Ключи человекопонятные: `button.save`, `form.email.label`.
- На сервере — `next-i18next` провайдеры. На клиенте — `react-i18next` хуки (`useTranslation`).

## Icons
- По умолчанию — `lucide-react`. Размеры и цвет — через Tailwind классы.
- `react-icons` — если иконка отсутствует в lucide.

## Animations (framer-motion)
- Небольшие, самодостаточные анимации. Избегать сложных таймлайнов.
- Производительность: не анимировать крупные контейнеры/скролл-области без необходимости.

## State & data
- Локальное состояние — React hooks.
- Избегать глобальных стейт-менеджеров без обоснования.
- Данные в Next:
  - Серверные компоненты предпочитаются для чтения данных.
  - Контроль кэша: `fetch` с опциями `cache`, `next: { revalidate }`.
  - Обработку ошибок и загрузки — через `error.tsx` и `loading.tsx` в маршрутах.

## Performance
- Мемоизируй вычисления и колбэки (`useMemo`, `useCallback`) на горячих путях.
- Избегай анонимных функций в пропсах при частом ререндере.
- Разделяй бандл через динамический импорт `next/dynamic` при необходимости.
- Изображения — `next/image`. Указывать `sizes`, разумные `priority`.

## API & errors
- Слои: `src/lib/api/` для клиентов и оберток fetch.
- Явная обработка ошибок, не проглатывать исключения.
- Никогда не логируй чувствительные данные. Логи — безопасные, без PII/секретов.

## Testing (если используется)
- Юнит-тесты для утилит и критичных компонентов.
- Договориться о покрытии минимум: XX% (задать при необходимости).

## Lint & format
- ESLint — без предупреждений в CI. Исправлять или добавлять обоснованные исключения.
- Import order: builtin, external, internal; группы разделять пустой строкой.
- Prettier как источник истины форматирования.

## Git & CI
- Коммиты — Conventional Commits: feat, fix, refactor, chore, docs, test, perf, build, ci.
- PR:
  - Четкое описание: что, зачем, как проверить.
  - Размер умеренный; большие изменения — дробить.
  - Все проверки CI должны проходить.
- Не коммитить .env и секреты.

## Tooling
- Пакеты устанавливать только yarn: `yarn add <pkg>`, dev: `yarn add -D <pkg>`.
- Скрипты в package.json должны быть кроссплатформенными.

## AI output rules
- Всегда соответствуй правилам выше.
- Не генерируй реальные секреты, токены, пароли, ключи — использовать плейсхолдеры (<TOKEN>, <PASSWORD>, <API_URL>).
- Если изменяешь существующий файл — предоставляй diff-сниппет только нужного фрагмента.
- Предпочитай TypeScript. Для UI — функциональные компоненты, Tailwind, i18n.
- Если есть сомнения по требованиям — задай уточняющие вопросы перед генерацией кода.
- Назначение: единый свод правил редактирования кода AI-агентами в этом репозитории.
- Обязательны к соблюдению для любых автоматизированных правок.

## Нельзя изменять

- Любые строки или блоки кода, помеченные маркером важности:
  - `// IMPORTANT` — запрещено менять, удалять, переносить или форматировать эти строки.
  - `/* IMPORTANT */` — запрещено менять содержимое в пределах такого комментария.
- Если требуется изменение «важного» кода, сначала создайте отдельный PR/issue с пояснением причин и ожидаемым эффектом.

## Разрешено

- Внесение правок вокруг «важных» фрагментов без изменения самих «важных» строк/блоков.
- Нефункциональное форматирование за пределами «важных» строк (переносы строк, пробелы вне важного участка).

## Как помечать защищённые области

- Для одиночных строк: добавьте `// IMPORTANT` в конце строки.
- Для блоков:
  - Начало: `// IMPORTANT START`
  - Конец: `// IMPORTANT END`
  - Всё между этими комментариями считается неизменяемым.

## Исключения (точечно)

- Если изменение необходимо и санкционировано, добавьте рядом временный маркер-разрешение:
  - `// AI:ALLOW_MODIFY` — только для конкретной строки/следующего блока.
  - После внесения правок маркер должен быть удалён ревьювером.

## Общие рекомендации для AI-правок

- Никогда не удаляйте и не изменяйте комментарии с требованиями/предупреждениями.
- Не рефакторьте публичные API без явного запроса/задачи.
- Соблюдайте существующий стиль кода и форматирование.
- При сомнениях — предложите изменения в тексте PR/коммита, а не применяйте их автоматически.

## Практики, сформированные сообществом

- Общие ограничения
  - Не изменять код, помеченный как важный (`// IMPORTANT`, `// IMPORTANT START/END`).
  - Не править автогенерируемые файлы и артефакты: `node_modules/`, `.next/`, `build/`, `dist/`, lock-файлы, сгенерированные типы/SDK.
  - Не вносить ломающие изменения в публичные API без явной задачи/миграционного плана.

- Объём и область правок
  - Делать минимально необходимые правки, без скрытого рефакторинга.
  - Крупные изменения дробить на логические PR.
  - Не перемещать файлы/не переименовывать модули без причины и отдельной задачи.

- Стиль, линтер, форматирование
  - Следовать ESLint/Prettier/Tailwind правилам проекта.
  - Не отключать линтер глобально; если нужно — только точечно и с комментарием.
  - Сохранять строгую типизацию (TypeScript), избегать `any` без необходимости.

- Тесты и сборка
  - Любая функциональная правка требует зелёной сборки и тестов.
  - Для изменений поведения — добавлять/обновлять тесты.
  - Не снижать покрытие тестами без согласования.

- Безопасность и секреты
  - Не добавлять секреты/ключи в код. Пользоваться переменными окружения.
  - Проверять лицензии/вес новых зависимостей.

- Зависимости
  - Обновлять по semver; фиксировать версии согласно политике проекта.
  - Не править package.json/lock вручную — только через `install`/CI.

- Документация и комментарии
  - Не удалять важные комментарии и докблоки.
  - Не писать очевидные/избыточные комментарии, которые повторяют код (комментируйте «почему», а не «что»; улучшайте читаемость кода вместо комментариев).
  - Обновлять README/миграционные заметки при изменении сценариев.

- Git и PR-практики
  - Коммиты по Conventional Commits: `feat:`, `fix:`, `chore:`, `refactor:`, `docs:` …
  - PR с мотивацией, рисками, планом отката и ссылкой на issue.
  - Не смешивать функциональные изменения и форматирование.

- Next.js/React-специфика
  - Клиентские хуки использовать только в компонентах с `"use client"`.
  - Не использовать `i18n` из `next.config` с App Router; применять провайдер/роутинг.
  - `viewport` — через export `viewport`; шрифты с `display: swap`, `preconnect`.
  - Использовать `next/image`, ленивую загрузку, избегать тяжёлых анимаций вне вьюпорта.

- i18n
  - Не хардкодить строки — использовать `t()`; поддерживать синхронность `en/ru` JSON.
  - Не менять ключи без обновления переводов; не вкладывать лишний HTML в переводы.

- Доступность и UX
  - Сохранять aria-атрибуты/role, фокус-стили и навигацию с клавиатуры.
  - Кнопки/таргеты — не менее 44px на тач-устройствах.

- Производительность
  - Анимации — через transform/opacity, учитывать `prefers-reduced-motion`.
  - Динамический импорт секций ниже фолда.

- React оптимизация
  - **Обязательно оборачивать в `useCallback`** функции, которые:
    - Передаются как пропсы дочерним компонентам
    - Используются в зависимостях других хуков (useEffect, useMemo)
    - Содержат сложную логику (навигация, API вызовы, обработчики событий)
    - Могут вызывать лишние ре-рендеры
  - Примеры обязательного использования:
    ```typescript
    // ✅ Обработчики событий
    const handleClick = useCallback(() => {
      // сложная логика
    }, [dependencies]);

    // ✅ Функции навигации
    const switchLocale = useCallback(() => {
      // логика смены языка
    }, [pathname, router]);

    // ✅ API вызовы
    const fetchData = useCallback(async () => {
      // API запрос
    }, [params]);
    ```
  - Правильные зависимости: включать все внешние значения из замыкания
  - Исключения: простые функции без зависимостей, не передаваемые как пропсы

  - **Обязательно использовать `useMemo`** для:
    - Тяжелых вычислений и трансформаций данных
    - Фильтрации и сортировки больших массивов
    - Создания объектов/массивов, передаваемых как пропсы
    - Вычислений, зависящих от нескольких значений
  - Примеры:
    ```typescript
    // ✅ Тяжелые вычисления
    const expensiveValue = useMemo(() => {
      return heavyCalculation(data);
    }, [data]);

    // ✅ Фильтрация/сортировка
    const filteredItems = useMemo(() => {
      return items.filter(item => item.active).sort((a, b) => b.date - a.date);
    }, [items]);

    // ✅ Объекты для пропсов
    const contextValue = useMemo(() => ({
      user,
      updateUser: setUser
    }), [user]);
    ```

  - **Не использовать `useMemo` для стабильных модульных констант**
    - Не оборачивайте в `useMemo` значения, объявленные на уровне модуля (вне компонента) и не зависящие от пропсов/состояния — их ссылка стабильна по определению.
    - Если нужно передать вниз неизменяемый массив/объект, определите его на уровне модуля. Если требуется производная структура, мемоизируйте именно преобразование, а не исходную константу.
    ```typescript
    // ❌ Плохо: бесполезная мемоизация модульной константы
    const items = [1, 2, 3];
    function List() {
      const memoItems = useMemo(() => items, []);
      return <div>{memoItems.join(",")}</div>;
    }

    // ✅ Хорошо: используем модульную константу напрямую
    const items2 = [1, 2, 3];
    function List2() {
      return <div>{items2.join(",")}</div>;
    }

    // ✅ Если нужна производная структура — мемоизируем именно вычисление
    const base = [1, 2, 3];
    function SortedList() {
      const sorted = useMemo(() => [...base].sort(), [/* зависимости, если есть */]);
      return <div>{sorted.join(",")}</div>;
    }
    ```

  - **Использовать `React.memo`** для компонентов, которые:
    - Часто ре-рендерятся с теми же пропсами
    - Содержат тяжелую логику рендеринга
    - Передаются как дочерние компоненты
  - Пример:
    ```typescript
    // ✅ Мемоизация компонентов
    const ExpensiveComponent = React.memo(({ data, onAction }) => {
      return <div>{/* heavy rendering */}</div>;
    });
    ```

  - **Строгая типизация TypeScript:**
    - Всегда определять интерфейсы для пропсов и данных
    - Избегать `any` - использовать `unknown` с type guards
    - Использовать generic типы для переиспользуемых компонентов
    - Типизировать события и обработчики
  - Примеры:
    ```typescript
    // ✅ Интерфейсы для данных
    interface User {
      id: string;
      name: string;
      email: string;
    }

    // ✅ Типизированные пропсы
    interface ComponentProps {
      user: User;
      onUpdate: (user: User) => void;
      isLoading?: boolean;
    }

    // ✅ Type guards вместо any
    const handleData = (data: unknown) => {
      if (isUser(data)) {
        // data теперь типизирован как User
      }
    };

    // ✅ Generic компоненты
    interface ListProps<T> {
      items: T[];
      renderItem: (item: T) => React.ReactNode;
    }
    ```
